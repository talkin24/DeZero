

# TIL - Deep Learning from Scratch 3

<br>

## 제1고지: 미분자동계산

<br>

### Step1.

- `self.변수`는 인스턴스 변수

- 벡터를 다룰때 차원이라는 말에 주의. 3차원 벡터와 3차원 배열은 다른 뜻.

  

### Step2.

- `__call__` 메서드는 파이썬의 특수 메서드. 이 메서드를 정의하면 f = Function() 형태로 함수의 인스턴스를 변수 f에 대입해두고, 나중에 f(...) 형태로 `__call__` 메서드를 호출할 수 있음
- 상속해서 사용해야할 메서드를 직접 호출하지 않게 하기위해 예외를 발생시킬 수 있음.



### Step3.

- 계산그래프를 이용하면 각 변수에 대한 미분을 효율적으로 계산할 수 있음



### Step4.

- 수치미분: 극한을 이용할 수 없으니, 아주 미세한 차이를 이용하여 함수의 변화량을 구하는 방법
- 중앙차분: 수치미분에서 발생할 수밖에 없는 근사오차를 줄이기 위해 사용. f(x)와 f(x+h)의 차이를 구하는 대신, f(x-h)와 f(x+h)의 차이를 구함
  - 중앙차분에서 직선의 기울기는 f(x + h) - f(x - h) / 2h
- 해석적으로 계산한다고 함은 수식 변형만으로 답을 유도한다는 뜻
- 수치미분의 큰 문제1: 오차가 존재한다는 것. 수치미분에 오차가 포함되기 쉬운 이유는 '자릿수 누락'
- 수미치분의 큰 문제2: 계산량이 많음
- 위의 2가지 문제를 해결하기 위해 등장한 것이 backpropagation.
- 역전파는 복잡한 알고리즘이라 버그가 섞여들어가기가 쉬움. 그래서 역전파를 정확히 구현했는지 확인하기 위해 수치 미분의 결과를 이용(기울기 확인)



### Step5.

- 수치미분은 계산 비용과 정확도 면에서 문제가 있음 -> 역전파로 해결
- 역전파를 이용하면 미분을 효율적으로 계산할 수 있고 결괏값의 오차도 더 작음
- 합성함수의 미분은 구성 함수들이 미분의 곱으로 분해할 수 있음
- 출력에서 입력 방향으로 계산되는 이유는 y의 미분값을 전파하기 위해서, 즉 y를 중요요소로 대우하기 때문
- 머신러닝은 주로 대량의 매개변수를 입력받아 마지막 손실함수를 거쳐 출력을 내보냄
  - 이때 손실함수의 출력은 단일한 스칼라값이며, 이 값이 중요요소임
  - 따라서 손실함수의 각 매개변수에 대한 미분 계산이 필요한데, 이 경우 미분값을 출력에서 입력 방향으로 전파하면 한 번의 전파만으로 모든 매개변수에 대한 미분을 계산할 수 있음
  - 이렇게 계산이 효율적으로 이뤄지므로 미분을 반대방향으로 전파하는 방식을 이용함
- 순전파의 경우, 통상값. 역전파는 미분값 계산에 유리
- 역전파 시에는 순전파 시 이용한 데이터가 필요!
  - 따라서 역전파를 구현하기 위해선 순전파를 먼저 수행하고, 이때 각 함수가 입력 변수의 값을 기억해 두어야 함



### Step6.

- 순전파에서 input을 self.input에 저장하여 역전파 시 사용



### Step 7.

- Define-by-Run: 딥러닝에서 수행하는 계산들을 계산 시점에 '연결'하는 방식. '동적 계산 그래프'
-  리스트 데이터 구조를 응용하면 수행한 계산을 리스트에 추가해 나가는 것만으로 어떠한 계산 그래프의 역전파도 제대로 해낼 수 있음(웬거트 리스트)
- 변수 관점에서 함수는 창조자 혹은 부모
- 동적 계산 그래프는 실제로 계산이 이루어질 때 변수에 관련 '연결'을 기록하는 방식으로 만들어짐
- 연결된 Variable과 Function이 있다면 계산 그래프를 거꾸로 거슬러 올라갈 수 있음
- assert문은 그 평가 결과가 True가 아니면 예외가 발생. 따라서 조건을 충족하는지 여부를 확인하는데 사용할 수 있음
- 역전파 구현 순서
  1. 함수를 가져온다
  2. 함수의 입력을 가져온다
  3. 함수의 backward 메서드를 호출한다



### Step 8.

- 재귀를 반복으로 바꿈으로써 효율 개선 가능
- 재귀는 함수를 재귀적으로 호출할 때마다 중간 결과를 메모리에 유지하면서 처리를 이어감
- 따라서 반복문의 효율이 일반적으로 더 좋음. 그러나 메모리 성능의 확장으로 보통 재귀 사용은 크게 문제가 되진 않음



### Step 9.

- `np.ones_like()`는 입력 값과 형상과 데이터 타입이 같은 ndarray 인스턴스 생성. 전부 1로 채워줌.
- 0차원 ndarray 인스턴스를 사용하여 계산하면 결과 값이 numpy.float64나 dumpy.float32로 달라짐



### Step 10.

- 테스트를 해야 실수를 예방할 수 있으며, 테스트를 자동화해야 소프트웨어의 품질을 유지할 수 있음
- 파이썬으로 테스트할 때는 표준 라이브러리에 포함된 unittest를 사용하면 편함
- `unittest.TestCase.assertEqual` : 주어진 두 객체가 동일한지 판별
- `$python -m unittest 파일명` 처럼 -m unittest 인수를 제공하면 파이썬 파일을 테스트 모드로 실행할 수 있음

- 테스트 케이스가 많아질수록 square 함수의 신뢰도도 높아질 것임
- 기울기 확인: 수치 미분으로 구한 결과와 역전파로 구한 결과를 비교하여 그 차이가 크면 역전파 구현에 문제가 있다고 판단
- `np.allclose(a,b)` 는 ndarray 인스턴스인 a와 b의 값이 가까운지 판정(기울기를 확인하는 대상의 계산에 따라 인수를 미세하게 조정해야 할 수 있음)
- 테스트 파일들은 하나의 장소에 모아 관리하는 것이 일반적
- CI도구와 연계하면 소스 코드를 지속해서 테스트 할 수 있음
- 컴퓨터 프로그램에서 미분을 계산하는 방법은 크게 3가지
  1. 수치미분
     - 구현하기 쉬움
     - 출력에 오차가 포함되기 쉽고, 계산 비용이 높음
  2. 기호미분
     - 수식이 크게 부풀어 오르기 쉬움
  3. 자동미분
     - 연쇄법칙 활용 -> 효율적, 정밀하게 계산
     - 역전파도 자동미분에 속함
     - forward mode / reverse mode(역전파)



<br>

## 제2고지: 자연스러운 코드로

<br>

### Step 11.



### Step 12.

- 함수의 반환값이 한개라면 굳이 리스트로 반환하지 않게 코드를 짜는 것이 더 좋다
- 입력 인수 앞에 *을 붙이면 리스트를 사용하는 대신, 가변 길이 인수를 건네 함수를 호출할 수 있음
- 코드의 개선은 2가지 방향으로 이루어질 수 있음
  - 함수를 사용하는 사람을 위해
  - 함수를 구현하는 사람을 위해
- 함수를 호출할 때 *를 붙이면 리스트 언팩
  - ex) `xs = [x0, x1] `일 때, `self.forward(*xs)` 를 하면 `self.forward(x0, x1)` 로 호출하는 것과 동일하게 동작함

- 클래스를 파이썬 함수로 사용하기 위해 다음과 같이 코드를 짤 수 있다

  ```python
  def add(x0, x1):
  	return Add()(x0, x1)
  ```



### Step 13.

- 상류에서 흘러오는 미분값을 그대로 흘려보내는 것이 덧셈의 역전파

- 입력이 1개, 출력이 2개인 경우도 얼마든지 가능

  


### Step 14.

- 동일한 변수가 반복되어 사용되었을 때 문제 해결

- `+=` 를 대신 사용했을때 문제가 발생할 수 있다(because of 인플레이스 연산)

  - 누적대입연산자인 +=를 쓰면 변수의 객체 ID가 변하지 않음. 즉 메모리 위치가 동일하다는 뜻으로 값만 덮어쓰게 된것(= 인플레이스 연산)

  - 반면 `x = x + x` 를 실행하면 객체 ID가 달라짐 

  - 따라서 메모리 효율 측면에서는 인플레이스 연산이 우수함

  - 그러나 누적대입연산자는 객체의 값만 바뀌게 되므로, 기존 값까지 전부 변하게 됨

    ```python
    x = Variable(np.array(3))
    y = add(x,x)
    y.backward()
    
    print(y.grad, id(y.grad)) #  2, 4427494343
    print(x.grad, id(x.grad)) #  2, 4427494343
    ```

  - 누적대입연산자를 사용하지 않고 `x.grad = x.grad + gx` 로 수정 시 

    ```python
    print(y.grad, id(y.grad)) #  1, 4034494234
    print(x.grad, id(x.grad)) #  2, 4427494343 
    ```

    

- 동일 변수를 반복사용하여 '다른'계산을 할 때 생기는 문제 해결(메모리 절약을 위해)



### Step 15.

- 그래프의 연결된 상태를 위상(topology)라고 한다.
- 역전파 시 세대 수가 큰 쪽부터 처리하면 '부모'보다 '자식'이 먼저 처리됨을 보장할 수 있음



### Step 16.

- 함수의 출력값은 부모 세대 + 1
- 입력변수와 함수는 동일한 세대로 설정
  - 입력변수가 둘 이상이면 가장 큰 세대의 수를 선택
- 정렬 후 pop을 하는 것보다 우선순위 큐(heapq)를 사용하는 것이 더 효율적

- 중첩함수는 다음 두가지 조건을 충족할 때 적합함
  - 감싸는 메서드 안에서만 이용
  - 감싸는 메서드에 정의된 변수를 사용해야 한다.



### Step 17.

- 파이썬은 필요 없어진 객체를 메모리에서 자동으로 삭제함

- 그래도 코드를 제대로 작성하지 않으면 메모리 누수 혹은 메모리 부족 등의 문제가 발생

- 특히 신경망에서는 큰 데이터를 다루는 경우가 많아 메모리 관리를 제대로 하지 않으면 실행시간이 오래 걸리는 일이 자주 발생함

- CPython (인터프리터)의 메모리 관리는 두가지 방식으로 진행됨

  1. 참조수를 세는 방식(참조 카운트)
  2. 세대를 기준으로 쓸모없어진 객체를 회수(가비지 컬렉션)

- 참조카운트

  - 구조가 간단하고 속도도 빠름
  - 모든 객체는 참조 카운트가 0인 상태로 생성되고, 다른 객체가 참조할 때마다 1씩 증가함
  - 반대로 객체에 대한 참조가 끊길 때마다 1만큼 감소하다가 0이되면 인터프리터가 자동으로 회수해감
  - 순환참조는 참조 카운트로 해결할 수 없음

- 순환참조

  ```python
  a = obj()
  b = obj()
  c = obj()
  
  a.b = b
  b.c = c
  c.a = a
  
  a = b = c = None
  ```

  마지막 줄이 실행된다고 해도 참조 카운트가 0이 되지 않음

  => GC가 필요!

- GC(가비지콜렉션)

  - 메모리가 부족해지는 시점에 파이썬 인터프리터에 의해 자동으로 호출(명시적 호출도 가능)
  - GC가 있다고 해도 순환참조가 있으면 전체 메모리 사용량이 커지는 원인이됨

- weakref.ref 함수를 사용하여 약한 참조를 만들 수 있음



### Step 18.

- 많은 경우 머신러닝에서는 역전파로 구하고 싶은 미분값은 말단 변수뿐일 때가 대부분

- 역전파하는 경우엔 참조할 변수들을 미리 inputs에 보관해야함. 하지만 때로는 미분값이 필요 없는 경우도 있고, 이 경우에는 중간 계산 결과를 저장할 필요가 없음

  - 학습 시에는 미분값을 구해야 하지만, 추론 시에는 단순 순전파만 하기 때문에 중간 계산 결과를 버리면 메모리 사용량을 크게 줄일 수 있음

- 설정 데이터는 단 한군데에만 존재하는 것이 좋음. 그래서 Config 클래스는 인스턴스화 하지 않고 '클래스' 상태로 이용함. 인스턴스는 여러개 생성할 수 있지만 클래스는 항상 하나만 존재하기 때문

- with문은 후처리를 자동으로 사용하고자 할때 사용하는 구문

  ```python
  f = open('sample.txt', 'w')
  f.write('hello, world!')
  f.close()
  
  with open('sample.txt', 'w') as f:
  	f.write('hello, world!')
  ```

- config를 일시적으로 전환할 때, with문을 사용하는 경우 많음

- `@contextlib.contextmanager` 데코레이터를 달면 문맥을 판단하는 함수가 만들어짐

  ```python
  import contextlib
  
  @contextlib.contextmanager
  def config_text():
  	print('start') # 전처리
    try:
      yield
    finally:
      print('done') # 후처리
    
  with config_test():
    print('process...')
    
    
  '''
  start
  process...
  done
  '''
  ```



### Step 19.

- 변수에 이름을 붙일 수 있다면, 계산 그래프를 시각화할 때 변수 이름을 그래프에 표시할 수 있음
  - `x = Variable(np.array(1.0), 'input_x')` 라고 작성하면 변수 x의 이름은 input_x가 됨
- Variable은 데이터를 담는 '상자' 역할을 함. 그러나 사람 입장에서 중요한 것은 상자가 아니라 그 안의 '데이터'. 그래서 Variable이 데이터인 것처럼 보이게 하는 장치가 필요
- 머신러닝 시스템은 다차원 배열을 기본 데이터 구조로 사용. 따라서 Variable 클래스는 스칼라는 무시하고 ndarray만 취급하기로 함.
- `@property` 를 사용하면 메서드를 인스턴스 변수처럼 사용할 수 있음
  - ex) x.shape() 대신 x.shape로 호출할 수 있음
- dtype을 지정하지 않으면, ndarray인스턴스는 float64 또는 int64로 초기화됨. 한편 신경망에서는 float32를 사용하는 경우가 많음
- `__len__` 이라는 특수 메서드를 구현하면 Variable 인스턴스에 대해서도 len 함수를 사용할 수 있게 됨
- `__repr__` 이라는 특수메서드를 사용하면 print 함수를 정의할 수 있게 됨



### Step 20.

- 연산자를 오버로드 하면 +와 * 같은 연산자 사용 시 사용자가 설정한 함수가 호출됨. 파이썬에서는 `__add__` 와 `__mul__` 같은 특수 메서드를 정의함으로써 사용자 지정함수가 호출되도록 함

- 파이썬에서는 함수도 객체이므로 함수 자체를 할당할 수 있음

  ```python
  Variable.__mul__ = mul
  Variable.__add__ = add
  ```

  



### Step 21.

- `y = 2.0 * x` 의 연산이 되려면 `__rmul__` 연산자가 구현되어야 함
- 연산자 우선순위도 고려해야 함





### Step 22.

- 새 연산자 추가 순서

  1. Function 클래스를 상속하여 원하는 함수 클래스를 구현
  2. 파이썬 함수로 사용할 수 있도록 함
  3. Variable 클래스의 연산자를 오버로드 함

  

### Step 23.

- `__init__.py` 는 모듈을 임포트할 때 가장 먼저 실행되는 파일

  - 이 파일에서 미리 임포트를 해두면 각 모듈들을 일일이 임포트할 필요가 없게됨

    ```python
    from dezero.core_simple import Variable
    from dezero import Variable
    ```

- 패키지가 설치되면 해당 패키지가 파이썬 검색 경로에 자동으로 추가됨

- `__file__` 변수는 구글 코랩이나 파이썬 인터프리터의 인터랙티브 모드에서는 정의되어 있지 않음



### Step 24.

- 위키백과의 "Test functions for optimization" 페이지를 보면 테스트 함수 대표적 예시들을 확인할 수 있음

- 딥러닝 프레임 워크는 동작 방식에 따라 크게 두가지로 나눌 수 있음. 어느 한 방식이 절대적으로 유리한 것은 아니기 때문에 두 모드 모두 지원하는 프레임워크도 많음
  1. 정적 계산 그래프(Define-and-Run)
     - 계산 그래프를 정의한 다음 데이터를 흘려 보냄
     - 따라서 계산 그래프 정의와 데이터 플려보내기 처리가 분리되어 있음
     - 이런 방식 프레임워크 대부분은 도메인 특화 언어를 사용하여 계산을 정의(파이썬 위에서 동작하는 새로운 프로그래밍 언어)
     - 계산 효율이 장점
     - 컴파일에 따라 다른 실행 파일로 변환할 수도 있음. 파이썬 자체가 주는 오버헤드가 사라지므로 IoT기기처럼 자원이 부족한 에지 전용 환경에서는 중요한 특징
     - 학습을 여러 대의 컴퓨터에 분산해 수행하는 경우에도 유리. 계산 그래프 자체를 분할하여 여러 컴퓨터로 분배하는 시나리오는 사전에 전체 계산 그래프가 구축되어 있어야만 가능
  2. 동적 계산 그래프(Define-by-Run)
     - 데이터를 흘려보냄으로써 계산 그래프가 정의됨
     - 데이터 흘려보내기와 계산 그래프 구축이 동시에 이루어짐
     - 이런 방식의 프레임워크는 넘파이를 사용하는 일반적인 프로그래밍과 똑같은 형태로 코딩할 수 있음
     - 도메인 특화 언어가 필요 없음. 즉 파이썬의 if문이나 for문 등을 그대로 사용하여 계산 그래프를 만들 수 있음
     - 디버깅도 파이썬 프로그램으로 할 수 있으므로 유리

<br>

## 제3고지: 고차 미분 계산

<br>

### Step25. 계산 그래프 시각화 - 1

- Graphviz는 그래프를 시각화해주는 도구
- 각 노드 이름 뒤에 대괄호를 넣으면 옵션 지정 가능



### Step26. 계산 그래프 시각화 - 2

- 함수 앞에 밑줄(_)이 붙는 이유는 이 함수를 로컬에서만 사용할 것이기 때문
- 객체 ID는 다른 객체와 중복되지 않기 때문에 노드의 ID로 사용하기에 적합함
- 계산그래프를 dot언어로 변환 시에는 노드 추적의 순서는 중요하지 않음
- '~'는 사용자의 홈 디렉토리를 뜻함
- subprocess.run 함수를 사용하면 파이썬에서 외부 프로그램을 호출할 수 있음



### Step27.  테일러 급수 미분

- sin함수의 미분은 해석적으로 풀림
- a=0 일때의 테일러 급수를 매클로린 전개라고 함



### Step28. 함수 최적화

- 로젠브록 함수는 최적화 문제의 벤치마크 함수로 자주 사용됨
- 경사하강법은 로젠브록 함수 같이 골짜기가 길게 뻗은 함수에는 잘 대응하지 못함



### Step29. 뉴턴 방법으로 푸는 최적화(수동계산)

- 경사하강법은 일반적으로 수렴이 느리다는 단점 존재
- 경사하강법을 대체할 수 있는 수렴이 더 빠른 방법중 하나 -> 뉴턴방법
- 경사하강법에서는 lr을 수동으로 정하나, 뉴턴방법은 2차 미분을 이용하여 자동으로 조정
- 물리 세계의 예를 들면 속도 정보만 사용하는 것이 경사하강법이고, 속도와 가속도 정보까지 사용하는 것이 뉴턴방법임



### Step30. 고차 미분 (준비 편)

- 순전파 시 계산 그래프(연결)가 만들어지고, data가 채워짐
- 역전파 시 grad가 채워짐



### Step31. 고차 미분 (이론 편)

- 그래프의 연결은 순전파 시 만들어지고, 역전파 계산 시에는 만들어지지 않음

- 역전파를 계산할 때도 '연결'이 만들어진다면, 고차 미분을 자동으로 계산할 수 있게 됨

- 순전파 시에는 입력이 x, 출력이 y / 역전파 시에는 입력이 gy, 출력이 gx



### Step32. 고차 미분 (구현 편)

- Add는 역전파 시 출력에서 전해지는 미분값을 입력쪽으로 전달하는게 다임
- 실무에서 역전파가 단 1회만 수행되는 경우가 압도적으로 많음



### Step33. 뉴턴 방법으로 푸는 최적화(자동 계산)

- 미분값이 남아있는 상태에서 새로운 역전파를 수행하면 새로운 미분 값이 더해짐



### Step34. sin 함수 고차 미분

- forward 메서드 안의 변수는 ndarray 인스턴스지만, backward 메서드 안의 모든 변수는 Variable 인스턴스
- `np.linspace(-7, 7, 200)` 의 의미는 -7부터 7까지 균일하게 200등분한 배열을 만들라는 것
- 넘파이 함수 대부분은 다차원 배열이 주어지면 원소별로 독립적으로 계산해줌



### Step35. 고차 미분 계산 그래프



### Step36. 고차 미분 이외의 용도

- 역전파의 계산그래프 연결은 고차 미분 이외에도 사용 가능
- **double back propagation: 역전파로 수행한 계산에 대해 또 다시 역전파**
- double backprop은 최적화 함수에 미분 결과(기울기)가 들어 있는 경우 사용됨
- WGAN-GP, MAML, TRPO 등 최신 유명 연구에서 double backprop 기능 사용 중



### 칼럼: 뉴턴방법과 double backprop 보충

$$
\nabla f(\mathbf x)
$$

- 위 기호는 기울기를 나타냄

$$
\nabla ^2 f(\mathbf x)
$$

- 위 기호는 헤세 행렬을 나타냄. 헤세행렬은 x의 두 원소에 대한 미분
- 

